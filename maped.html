<html>
<head>
  <title>maped</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>
  const maped_version = 0.65;

  function Map(){
    this.maped_version = maped_version;
    this.name = "new_map";
    this.grid_cols = 64;
    this.grid_rows = 64;
    this.unit_width = 16;
    this.unit_height = 9;
    this.allrooms = [];
    this.alldoors = [];
    this.roomgrid = [];
    this.nextroomnum = 0;
    this.nextdoornum = 0;
  }

  </script>

  <style type="text/css">
  body{
    padding: 0px;
    margin:0px;
    background-color: #bbbbbb;
  }
  .doorlink, .roomlink{
    border:1px solid blue;
    padding:0px;
    display:inline;
  }
  .tabbtn, .tabbtna{
    display:inline-block;
    width:48%;
    text-align: center;
    background-color: #aaaaaa;
    border:1px solid black;
  }
  .tabbtna{
    background-color: #999999;
  }
  #mcanvas{
    padding: 0px;
    margin:0px;

    border: 1px solid black;

  }
  #leftcontent{
    position:fixed;
    top:0;
    bottom:0;
    left:0;
    width:75%;
    height:100%;
  }
  #topbar{
    padding:0px;
    top:0px;
    height:4%;
    width:100%;
    border: 4px solid red;
  }
  #editorholder{
    display:block;
    padding: 0px;
    margin:0px;
    width:100%;
    height:69%;
    border: 4px solid purple;
    overflow:scroll;
  }
  #bottompanel{
    display:block;
    height:23%;
    padding-left:0px;
    margin:0px;
    border:4px solid blue;
    width:100%;

    overflow:scroll;
  }
  #rightpanel{
    padding:0px;
    margin:0px;
    border:4px solid green;
    position:fixed;
    width:24%;
    right:0;
    top:0;
    bottom:3;

  }
  #rightcontents{
    position:fixed;
    top:2em;

    width:24%;
    overflow-y:scroll;
  }


  /* Positions the plus sign 5px from the right. Centers it using the transform property. */

  .accordion .label::before {
    content: '+';
    color: white;
    position: absolute;
    top: 50%;
    right: 5px;
    font-size: 30px;
    transform: translateY(-50%);
  }

  /* Hides the content (height: 0), decreases font size, justifies text and adds transition */

  .accordion .content {
    position: relative;
    height:0;
    text-align: justify;
    padding:2px;
    overflow: hidden;
    transition: 0.5s;
  }

  /* Adds a horizontal line between the contents */

  .accordion hr {
    width: 98%;
    margin-left: 0;
    border: 1px solid grey;
  }
  .accordion .acontainer {
    position: relative;

    margin: 5px 5px;
    background-color: #aaaaaa;
  }

  /* Positions the labels relative to the .container. Adds padding to the top and bottom and increases font size. Also makes its cursor a pointer */

  .accordion .label {
    position: relative;
    padding: 5px 0;
    color: white;
    cursor: pointer;
  }
  /* Unhides the content part when active. Sets the height */

  .accordion .acontainer.active .content {

    height:2.5em;
    background-color: #eeeeee;
    overflow:scroll;
    animation: fadeEffect 1s;

  }

  /* Changes from plus sign to negative sign once active */

  .accordion .acontainer.active .label::before {
    content: '-';
    font-size: 30px;
  }

  /* Go from zero to full opacity */
  @keyframes fadeEffect {
    from {opacity: 0;}
    to {opacity: 1;}
  }
</style>
</head>
<body><div id="leftcontent"><div id="topbar">  <a id="exportJSON" onclick="exportJson(this);" ><button type="button">export map json</button></a>
|  upload map json:  <input id="ufile" type="file" name="map upload" accept=".json"/>


    <div style='display:inline;float:right'>
      current region:
        <select name="regionsel" onchange="{curregion = this.value;}">
          <option value="0">0</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
        </select> |
        current door type:
          <select name="doortypesel" onchange="{curdoortype = this.value;}">
            <option value="0">0</option>
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
          </select>
</div>
</div>
  <div id="editorholder">
  </div>
  <div id="bottompanel">
  </div>
</div>
  <div id="rightpanel">
    <div id="righttitle"></div>
    <div id="rightcontents">
    </div>
  </div>



    <script>
    const canvasholder = document.getElementById("editorholder");
    const rpanel = document.getElementById("rightpanel");
    const bpanel = document.getElementById("bottompanel");
    var canv;
    var accordion;
    var ctx;
    var grid_unit_width;
    var grid_unit_height;

    var roommode = true;
    var curroom;
    var curdoor;
    var curregion = 0;
    var curdoortype = 0;
var vw,vh;

    var bigger = true;
    var dsx,dsy,dex,dey = -1;

    var regcols = ["#990000","#994c00","#999900","#009900","#009999","#004c99","#4c0099","#990099"];
    var doorcols =["#ff9999","#ffcc99","#ffff99","#99ff99","#99ffff","#99ccff","#cc99ff","#ff99ff"];
    var map = null;

    init();
    updateroomlist();
    drawmap();

    function init(){

      map = new Map();
       vw = map.grid_cols*map.unit_width*4;

       vh = map.grid_rows*map.unit_height*4;

      for (var i = 0; i < map.grid_rows;i+=1){
        var newrow = [];
        for (var j=0;j < map.grid_cols;j+=1){
          newrow.push(-1);
        }
        map.roomgrid.push(newrow);
      }




      if (vw>vh){
        console.log("wide");
      }
      else{
        console.log("tall");
        bigger = false;
      }
      if (bigger){
        //vh = .8 * vh;
        //console.log(vw,vh);
        grid_unit_height = vh/map.grid_rows;
        grid_unit_width = vw/map.grid_cols;
        //console.log(vw,vh);
      }


      canvasholder.innerHTML="<canvas id='mcanvas' width='" + vw + "' height='" + vh + "'></canvas>";
      canv = document.getElementById('mcanvas');


      canv.addEventListener('mousedown', function(event) {
        var rect = canv.getBoundingClientRect(), // abs. size of element
              scaleX = canv.width / rect.width,    // relationship bitmap vs. element for X
              scaleY = canv.height / rect.height;
        var xval = (event.clientX - rect.left) * scaleX ,
        yval = (event.clientY - rect.top) * scaleY;
        mdown(xval,yval);
      }, false);
      canv.addEventListener('mouseup', function(event) {
        var rect = canv.getBoundingClientRect(), // abs. size of element
              scaleX = canv.width / rect.width,    // relationship bitmap vs. element for X
              scaleY = canv.height / rect.height;
        var xval = (event.clientX - rect.left) * scaleX ,
        yval = (event.clientY - rect.top) * scaleY;
        mup(xval,yval);
      }, false);
      canv.addEventListener('touchstart', function(event) {
        document.addEventListener("touchstart",function(e) {
          e.preventDefault();
        },false);
        var rect = canv.getBoundingClientRect(), // abs. size of element
              scaleX = canv.width / rect.width,    // relationship bitmap vs. element for X
              scaleY = canv.height / rect.height;
        var xval = (event.clientX - rect.left) * scaleX ,
        yval = (event.clientY - rect.top) * scaleY;
        mdown(xval,yval);
      }, false);
      canv.addEventListener('touchend', function(event) {
        document.removeEventListener("touchstart",function(e) {
          e.preventDefault();
        });
        var rect = canv.getBoundingClientRect(), // abs. size of element
              scaleX = canv.width / rect.width,    // relationship bitmap vs. element for X
              scaleY = canv.height / rect.height;
        var xval = (event.clientX - rect.left) * scaleX ,
        yval = (event.clientY - rect.top) * scaleY;
        mup(xval,yval);

      }, false);



      ctx = canv.getContext('2d');
      ctx.textAlign="center";
    }



    function mdown(xv,yv){
      var gx = Math.floor(xv / grid_unit_width);
      var gy = Math.floor(yv / grid_unit_height);
      dsx = gx;
      dsy = gy;

      //console.log(gx, gy);
    }

    function mup(xv,yv){
      if (dsx != -1 && dsy != -1){
        var gx = Math.floor(xv / grid_unit_width);
        var gy = Math.floor(yv / grid_unit_height);
        dex = gx;
        dey = gy;
        var nl = Math.min(dsx,dex);
        var nr = Math.max(dsx,dex);
        var nt = Math.min(dsy,dey);
        var nb = Math.max(dsy,dey);

        var nw = nr-nl;
        var nh = nb-nt;


        //started click on an existing room
        if (map.roomgrid[dsy][dsx] != -1){
          //ended click on an existing room
          if (map.roomgrid[gy][gx] != -1){
            //they are the same room
            if (map.roomgrid[dsy][dsx] == map.roomgrid[gy][gx]){
              curroom = map.allrooms[map.roomgrid[gy][gx]];
              roommode = true;
              curdoor = null;
              updateroomlist();
              drawmap();
            }
            else{
              //link rooms
              TryDoor([dsx,dsy],[gx,gy]);
            }
          }
          else{
            //expand room?
            TryExpand(map.allrooms[map.roomgrid[dsy][dsx]],[gx,gy]);
          }

        }
        else{
          TryNewRoom([nl,nt],nw,nh);
        }


        dsx = -1;
        dsy = -1;
      }

    }



    function TryNewRoom(tl,w,h){
      var allowed = true;
      //console.log("trying");
      //console.log(map.roomgrid);

      var rm = new Room(tl,w,h);
      for (let ru of rm.units){
        //console.log(ru);
        var check = map.roomgrid[ru[1]][ru[0]];
        //console.log(check);
        if (check != -1){
          //console.log(check);
          //console.log(ru , " is full");
          allowed = false;
        }
      }
      if (allowed){
        map.allrooms.push(rm);

        for (let ru of rm.units){
          map.roomgrid[ru[1]][ru[0]] = rm.id;
        }
        roommode = true;
        curdoor = null;
        curroom = rm;
        updateroomlist();
        drawmap();
      }
      else{
        map.nextroomnum-=1;
      }
    }

function TryExpand(rm,exto){
  console.log("trying expand");
  var allowed = true;
  var nl = Math.min(rm.tlunit[0],exto[0]);
  var nr = Math.max(rm.tlunit[0]+ rm.gridwidth-1,exto[0]);
  var nt = Math.min(rm.tlunit[1] ,exto[1]);
  var nb = Math.max(rm.tlunit[1] + rm.gridheight-1,exto[1]);
  for (var i = nl; i <= nr;i+=1){
    for (var j = nt; j <= nb;j+=1){
        if (map.roomgrid[j][i] != -1 && !(isArrayInArray(rm.units,[i,j]))){
          allowed = false;

          console.log("collided at " + [i,j]);

        }
    }
  }
  if (allowed){
    rm.tlunit=[nl,nt];
    rm.units = [];
    rm.gridwidth = (nr-nl)+1;
    rm.gridheight = (nb-nt)+1;
    for (var j=0;j<rm.gridheight;j+=1){
      for (var i=0;i<rm.gridwidth;i+=1){
        var ru = [rm.tlunit[0]+i,rm.tlunit[1]+j]
        rm.units.push(ru);
        map.roomgrid[ru[1]][ru[0]] = rm.id;
      }
    }
    curroom = rm;
    updateroomlist();
    drawmap();
  }
}


    function Room(sunit, w=0,h=0){
      this.id = map.nextroomnum;
      map.nextroomnum+=1;
      this.region = curregion;
      this.name = "room " + this.id;
      this.tlunit = sunit;
      this.units = [];
      this.gridwidth = w+1;
      this.gridheight = h+1;
      for (var j=0;j<this.gridheight;j+=1){
        for (var i=0;i<this.gridwidth;i+=1){
          var ru = [sunit[0]+i,sunit[1]+j]
          this.units.push(ru);
        }
      }
      this.doors = [];
    }

    function TryDoor(ufrom, uto){
      var allowed = true;
      if (map.allrooms[GetRoomIDByUnit(ufrom)] != null){
        for (let od of map.allrooms[GetRoomIDByUnit(ufrom)].doors){
          if (JSON.stringify(od.unitfrom) == JSON.stringify(uto) || JSON.stringify(od.unitto) == JSON.stringify(uto)){
            allowed = false;
            console.log("not allowed");
          }
          else{
            //  console.log(od.unitfrom, od.unitto, uto);
          }
        }
      }
      else
      {

        allowed= false;
      }

      if (allowed){

        var pfrs = JSON.parse(JSON.stringify(map.allrooms[GetRoomIDByUnit(ufrom)].units));
        pfrs = findClosestUnit(pfrs,uto);
        var ptrs = JSON.parse(JSON.stringify(map.allrooms[GetRoomIDByUnit(uto)].units));
        ptrs = findClosestUnit(ptrs,ufrom);
        var d = new Door(pfrs[0], ptrs[0]);

        map.allrooms[d.rfromid].doors.push(d);
        map.allrooms[d.rtoid].doors.push(d);
        map.alldoors.push(d);
        roommode = false;
        curdoor = d;
        curroom = null;
        updateroomlist();
        drawmap();

      }

    }

    function Door(ufrom,uto){
      this.id = map.nextdoornum;
      map.nextdoornum += 1;
      //console.log(ufrom);
      //  console.log(uto);
      this.rfromid = GetRoomIDByUnit(ufrom);
      //console.log(this.rfromid);
      this.rtoid = GetRoomIDByUnit(uto);
      //  console.log(this.rtoid);
      this.unitfrom = ufrom;
      this.unitto = uto;
      this.oneway = false;
      this.doortype = curdoortype;

    }


function removeDoor(dindex){
  var dr = map.alldoors[dindex];
  map.allrooms[dr.rtoid].doors.splice(map.allrooms[dr.rtoid].doors.indexOf(dr),1);
  map.allrooms[dr.rfromid].doors.splice(map.allrooms[dr.rfromid].doors.indexOf(dr),1);
  map.alldoors[dindex] = null;
  curdoor = null;

  updateroomlist();
  drawmap();
}


function removeRoom(rindex){
  var rr = map.allrooms[rindex];
  while (rr.doors.length > 0){
    removeDoor(rr.doors[0].id);
  }
  for (let ru of rr.units){
    map.roomgrid[ru[1]][ru[0]] = -1;
  }
  map.allrooms[rindex] = null;
  curroom = null;
  updateroomlist();
  drawmap();

}


    function GetRoomIDByUnit(unit){

      return map.roomgrid[unit[1]][unit[0]];

    }

    //

    function updatebottompanel(){

      bpanel.innerHTML = "";
      var htmlb = "";
      if (roommode){
        var rm = curroom;
        if (rm != null){
          htmlb += "<div class='bcontainer'>ROOM:&nbsp &nbsp";
          htmlb += "<button type='button' onclick='{removeRoom(" + rm.id + ")}'>delete</button><BR>";

          htmlb += "name: <input type='text' value='" + rm.name + "' onchange='{map.allrooms[" + rm.id + "].name=this.value;updateroomlist();}'><BR>";
          htmlb += "id: " + rm.id + "&nbsp;&nbsp;&nbsp;&nbsp;";
          htmlb += "<div style='display:inline;background-color:" + regcols[rm.region] + ";color:white;'>region: <select onchange='{map.allrooms[" + rm.id + "].region = this.value;updateroomlist();drawmap();}'>";

          for (var r = 0; r < 8; r += 1){
            htmlb += "<option value='"+r+"' ";
            if (r == rm.region){
              htmlb += "selected='selected'";
            }
            htmlb += ">"+r+"</option>"
          }
          htmlb += "</select></div><BR>";

          htmlb += "size: " + rm.gridwidth + "," + rm.gridheight+ "<BR>";
          htmlb += "units: " + JSON.stringify(rm.units) + "<BR>";
          htmlb += "doors: ";
          for (let dd of rm.doors){
            htmlb += "<div class='doorlink' id='" + dd.id + "'>" + dd.id + "</div>";
          }
          htmlb +=  "<BR>";
          htmlb += "</div>";
        }



      }
      else{
        var dr = curdoor;

        if (dr != null){
          htmlb += "<div class='bcontainer'>DOOR: &nbsp &nbsp";
          htmlb += "<button type='button' onclick='{removeDoor(" + dr.id + ")}'>delete</button><BR>";
          htmlb += "id: " + dr.id + "&nbsp;&nbsp;&nbsp;&nbsp;door type: " + dr.doortype + "<BR>";
          htmlb += "from: <div class='roomlink' id='" + dr.rfromid + "'>" + map.allrooms[dr.rfromid].name + "</div><BR>";
          htmlb += "to: <div class='roomlink' id='" + dr.rtoid + "'>" + map.allrooms[dr.rtoid].name + "</div><BR>";
          htmlb += "oneway: " + dr.oneway + "<BR>";
          htmlb += "</div>";
        }


      }
      bpanel.innerHTML = htmlb;





    }

    function updateroomlist(){


var htmls = "&nbsp;";

if (roommode){
  htmls += "<div class='tabbtna'><B>rooms</b> </div><div class='tabbtn' onclick='{roommode=false;curroom=null;updateroomlist();drawmap();}'>doors</div>";
}
else{
  htmls += "<div class='tabbtn' onclick='{roommode=true;curdoor=null;updateroomlist();drawmap();}'>rooms</div><div class='tabbtna'><b>doors</b></div>";
}
rpanel.children[0].innerHTML = htmls;
       htmls = "<div class='accordion'>";

      if (roommode){
        for (let rm of map.allrooms){
          if (rm != null){
            htmls +=  "<div class='acontainer";
            if (curroom == rm){
              htmls += " active";
            }
            htmls +="' id='" + rm.id + "'><div class='label' style='background-color:" + regcols[rm.region] + ";'>" + rm.name + " - [" + rm.tlunit + "]</div>";
            htmls += "<div class='content'>";
            htmls += "id: " + rm.id + "<BR>";
            htmls +=  "size: " + rm.gridwidth + "," + rm.gridheight+ "<BR>";
            htmls +=  "</div></div><hr>";
          }

        }
      }
      else{
        for (let rm of map.alldoors){
          if (rm != null){
            htmls +=  "<div class='acontainer";
            if (curdoor == rm){
              htmls += " active";
            }
            htmls +="' id='" + rm.id + "'><div class='label' style='color:black;background-color:" + doorcols[rm.doortype] + "'>door " + rm.id +"</div>";
            htmls += "<div class='content'>";
            htmls += "id: " + rm.id + "<BR>";
            htmls += "from: " + rm.rfromid + ", ";
            htmls += "to: " + rm.rtoid + "<BR>";

            htmls +=  "</div></div><hr>";
          }

        }

      }

      htmls += "</div>";
      rpanel.children[1].innerHTML = htmls;
      rpanel.children[1].scrollTop = rpanel.children[1].scrollHeight;
      if (document.getElementsByClassName("active")[0] != null)
      document.getElementsByClassName("active")[0].scrollIntoView();
      updatebottompanel();
      makecol();
    }




    function drawmap(){
      ctx.clearRect(0, 0, canv.width, canv.height);
      ctx.fillStyle = '#bbbbbb';
      ctx.fillRect(0, 0, canv.width, canv.height);
      drawgrid();
      for (let rm of map.allrooms){
        if (rm != null)
        drawroom(rm);
      }

      if (curroom != null){
        drawroom(curroom,true);
      }
      //  drawgrid();
      //updateroomlist();
      for (let dr of map.alldoors){
        if (dr != null)
        drawdoor(dr);
      }
      if (curdoor != null){
        drawdoor(curdoor,true);
      }




    }

    function drawroom(rm, highlight = false){
      ctx.beginPath();
      var rl = rm.tlunit[0] * grid_unit_width;
      var rt = rm.tlunit[1] * grid_unit_height;
      var rb = rt + (rm.gridheight * grid_unit_height);
      var rr = rl + (rm.gridwidth * grid_unit_width);
      var cx = rl + ((rr-rl)/2);
      var cy = rt + ((rb-rt)/2);
      ctx.moveTo(rl,rt);
      ctx.lineTo(rr,rt);
      ctx.lineTo(rr,rb);
      ctx.lineTo(rl,rb);
      ctx.lineTo(rl,rt);
      ctx.closePath();
      if (highlight){
        ctx.fillStyle = "rgba(255,255,255,.9)";
        ctx.strokeStyle = regcols[rm.region];
      }
      else{
        ctx.fillStyle = regcols[rm.region];
        ctx.strokeStyle = "black";
      }
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "white";
      if (highlight){
        ctx.fillStyle="blue";
      }
      ctx.fillText(rm.id,cx,cy+3);
    }

    function drawdoor(dr, highlight = false){

      ctx.beginPath();
      var rfcx = (dr.unitfrom[0]*grid_unit_width) + (grid_unit_width/2);
      var rfcy = (dr.unitfrom[1]*grid_unit_height) + (grid_unit_height/2);
      var rtcx = (dr.unitto[0]*grid_unit_width) + (grid_unit_width/2);
      var rtcy = (dr.unitto[1]*grid_unit_height) + (grid_unit_height/2);
      var cx = rfcx + (.5)*(rtcx-rfcx);
      var cy = rfcy + (.5)*(rtcy - rfcy);
      var dw = grid_unit_height / 3;
      var dh = dw/2;

      var dl = cx - dw;
      var ndr = cx + dw;
      var dt = cy - dh;
      var db = cy + dh;

      ctx.moveTo(dl,dt);
      ctx.lineTo(dl,db);
      ctx.lineTo(ndr,db);
      ctx.lineTo(ndr,dt);
      ctx.lineTo(dl,dt);
      ctx.closePath();
      ctx.strokeStyle="black";
      ctx.fillStyle = doorcols[dr.doortype];
      if (highlight){
        ctx.fillStyle = "rgba(255,255,255,.9)";
        ctx.strokeStyle = doorcols[dr.doortype];
      }

      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "black";
      if (highlight){
        ctx.fillStyle="blue";
      }
      ctx.fillText(dr.id,cx,cy+3);



    }

    function drawgrid(){
      for (var i=0;i<map.grid_cols;i+=1){
        ctx.beginPath();
        ctx.moveTo(i*grid_unit_width, 0);
        ctx.lineTo(i*grid_unit_width, vh);
        ctx.closePath();
        ctx.strokeStyle = "gray";
        ctx.stroke();
      }
      for (var j=0; j<map.grid_rows;j+=1){
        ctx.beginPath();
        ctx.moveTo(0,j*grid_unit_height);
        ctx.lineTo(vw,j*grid_unit_height);
        ctx.closePath();
        ctx.strokeStyle = "gray";
        ctx.stroke();
      }
    }


    function findClosestUnit(cunits, nunit) {
        return cunits.sort(function (a, b) {
          if ((Math.pow(a[0]-nunit[0],2) + Math.pow(a[1]-nunit[1],2)) < (Math.pow(b[0]-nunit[0],2) + Math.pow(b[1]-nunit[1],2)))
             return -1;
          if ((Math.pow(a[0]-nunit[0],2) + Math.pow(a[1]-nunit[1],2)) > (Math.pow(b[0]-nunit[0],2) + Math.pow(b[1]-nunit[1],2)))
            return 1;
          return 0;
        });
    }





    function makecol(){
      accordion = document.getElementsByClassName('acontainer');

      for (i=0; i<accordion.length; i++) {

        accordion[i].addEventListener('click', function () {

          if (this.classList.contains('active')){
            this.classList.remove('active');
            curroom = null;
            curdoor = null;
          }
          else{
            for (j=0; j<accordion.length; j++) {
              accordion[j].classList.remove('active');
            }
            this.classList.add('active');
            if (roommode){
              curdoor = null;
              curroom = map.allrooms[this.id];
            }
            else{
              curdoor = map.alldoors[this.id];
              curroom = null;
            }

          }
          updateroomlist();
          drawmap();
        })
      }

      var doorlinks = document.getElementsByClassName('doorlink');
      for (i=0; i<doorlinks.length; i++) {
        doorlinks[i].addEventListener('click', function () {
          roommode = false;
          curdoor = map.alldoors[this.id];
          curroom = null;
          //console.log("door clicked");
          updateroomlist();
          drawmap();

        });
      }

      var roomlinks = document.getElementsByClassName('roomlink');
      for (i=0; i<roomlinks.length; i++) {
        roomlinks[i].addEventListener('click', function () {
          roommode = true;
          curdoor = null;
          console.log(this.id);
          curroom = map.allrooms[this.id];

          //console.log("door clicked");
          updateroomlist();
          drawmap();

        });
      }




    }

    function exportJson(el) {

      var data = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(map));
      el.setAttribute("href", "data:"+data);
      el.setAttribute("download", "map.json");
    }


    var filesInput = document.getElementById("ufile");
    filesInput.addEventListener("change", function (event) {
      var files = event.target.files;
      var file = files[0];
      var reader = new FileReader();
      reader.addEventListener("load", function (event) {
        var nfile = event.target.result;

        map = JSON.parse(nfile);
        if (map.maped_version <= maped_version){
          curroom = null;
          updateroomlist();
          drawmap();
        }
        else{
          if (map.maped_version > maped_version){
            alert("unable to load map json file - map made with newer version of editor");
          }
          else{
            alert("unable to load map json file - missing maped_version");
          }
          location.reload();
        }


      });
      reader.readAsText(file);
    });
    function isArrayInArray(arr, item){
      var item_as_string = JSON.stringify(item);

      var contains = arr.some(function(ele){
        return JSON.stringify(ele) === item_as_string;
      });
      return contains;
    }
    </script>

  </body>
  </html>
